# データ型とリテラル
## データ型
- JavaScriptは動的型付け言語に分類される言語であるため、静的型付け言語のような**変数の型**はないが、、文字列、数値、真偽値といった**値の型**は存在し、これらの値の型のことを**データ型**と呼びます。
- データ型は大きく、**プリミティブ型**と**オブジェクト**の2つに分類される
- プリミティブ型(基本型)は、真偽値や数値などの基本的な値の型で、一度作成したらその値自体を変更できないというイミュータブル(immutable)の特性を持つ
  - JavaScriptでは、文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種として扱われる
- オブジェクト(複合型)はプリミティブ型ではないものであり、 オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合のことで、作成した後もその値自体を変更できるためミュータブル(mutable)の特性を持つ
  - オブジェクトは、値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言う

### プリミティブ型（基本型）
  - 真偽値（Boolean）: `true`または`false`のデータ型
  - 数値（Number）: `42` や `3.14159` などの数値のデータ型
  - 巨大な整数（BigInt）: ES2020から追加された`9007199254740992n`などの任意精度の整数のデータ型
  - 文字列（String）: `"JavaScript"` などの文字列のデータ型
  - undefined: 値が未定義であることを意味するデータ型
  - null: 値が存在しないことを意味するデータ型
  - シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型

### オブジェクト（複合型）
  - プリミティブ型以外のデータ
  - オブジェクト、配列、関数、正規表現、Dateなど
  > プリミティブ型でないものは、オブジェクトであると覚えていれば問題ない

### データ型を調べる(`typeof`)
- `typeof`演算子を使うことで、次のようにデータ型を調べることができる
```JavaScript
console.log(typeof true);// => "boolean"
console.log(typeof 42); // => "number"
console.log(typeof 9007199254740992n); // => "bigint"
console.log(typeof "JavaScript"); // => "string"
console.log(typeof Symbol("シンボル"));// => "symbol"
console.log(typeof undefined); // => "undefined"
console.log(typeof null); // => "object"
console.log(typeof ["配列"]); // => "object"
console.log(typeof { "key": "value" }); // => "object"
console.log(typeof function() {}); // => "function"
```
- `typeof null`が"object"となるのは、歴史的経緯のある仕様のバグ
- 他のプリミティブ型の値については、`typeof`演算子でそれぞれのデータ型を調べることができる
- 配列とオブジェクトがどちらも`"object"`という判定結果となるように、`typeof`演算子ではすべてのオブジェクトの種類を判定することはできない
> 基本的に`typeof`演算子は、プリミティブ型またはオブジェクトかを判別するもの

## リテラル
- プリミティブ型の値や一部のオブジェクトは、**リテラル**(プログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの)を使うことで簡単に定義できるようになっている
  - 例: `"`と`"`で囲んだ範囲が文字列リテラルで、これは文字列型のデータを表現する
- リテラル表現がない場合は、その値を作る関数に引数を渡して作成する
  - よく利用される主要な値にはリテラルが用意されている

### 真偽値（Boolean）
- 真偽値には`true`と`false`のリテラルがある
```JavaScript
true; // => true
false; // => false
```

### 数値（Number）
#### 整数リテラル
- 整数リテラルは4種類ある
  - 10進数: 数字の組み合わせ(先頭を`0`から開始すると8進数として扱われる場合がある)
  ```JavaScript
  console.log(1); // => 1
  console.log(10); // => 10
  console.log(255); // => 255
  ```
  - 2進数: `0b`（`0B`）の後ろに、`0`または`1`の数字の組み合わせ(`b`は2進数を表すbinary)
  ```JavaScript
  console.log(0b1111); // => 15
  console.log(0b10000000000); // => 1024
  ```
  - 8進数: `0o`（`0O`）の後ろに、`0`から`7`までの数字の組み合わせ(`o`は8進数を表すoctal)
  ```JavaScript
  console.log(0o644);  // => 420
  console.log(0o777);  // => 511
  ```
  - 16進数: `0x`（または`0X`）の後ろに、`0`から`9`までの数字と`a`から`f`(`A`から`F`)のアルファベットの組み合わせ
  ```JavaScript
  console.log(0xFF); // => 255
  console.log(0xff); // => 255(小文字で書いても意味は同じ)
  console.log(0x30A2); // => 12450
  ```

#### 浮動小数点数リテラル
- 浮動小数点数をリテラルとして書く場合には、2種類の表記がある
  - `3.14159` のような `.`（ドット）を含んだ数値
  ```JavaScript
  0.123; // => 0.123
  .123; // => 0.123(0からはじまる浮動小数点数は、0を省略して書くことができる)
  ```
  - `2e8` のような `e` または `E` を含んだ数値
  ```JavaScript
  2e8; // => 200000000
  ```

#### [ES2020] BigInt
- 数値リテラルで正確に扱える数値の最大値は`2^53-1`であり、これよりも大きな値を表現したり計算すると間違った結果となる場合があったため、ES2020では`BigInt`という新しい整数型のデータ型とリテラルが追加された
  - BigIntリテラルは、数値の後ろに`n`をつける
  ```JavaScript
  console.log(1n); // => 1n
  // 2^53-1より大きな値も扱える
  console.log(9007199254740992n); // => 9007199254740992n
  1.2n; // => SyntaxError(BigIntは整数を扱うデータ型であるため、小数点を含めた場合は構文エラーとなる)
  ```

### 文字列（String）
- 文字列リテラルは3種類あるが、その評価結果はすべて同じ

#### ダブルクォートとシングルクォート
- `"`（ダブルクォート）と`'`（シングルクォート）はまったく同じ意味
- 文字列リテラルは同じ記号で囲む必要があるため、文字列の中に同じ記号が出現した場合は、 `\'`のように\（バックスラッシュ）を使ってエスケープする
- どちらも改行を含んだ文字列は定義できず、構文エラー（SyntaxError）となる
  - 改行記号のエスケープシーケンス（`\n`）を使うことで複数行の文字列を書くことができる

#### [ES2015] テンプレートリテラル
- `（バッククォート）で囲んだ範囲を文字列とするリテラル
  - 複数行の文字列を改行記号のエスケープシーケンス（\n）を使わずにそのまま書くことができる
  - `${変数名}`と書くことで、その変数の値を埋め込むことができる

#### nullリテラル
- 「値がない」ということを表現する`null`値を返すリテラル
  - 値がない変数として定義し、参照できるようになる

### オブジェクトリテラル
- オブジェクトリテラルは`{}`（中カッコ）を書くことで、新しいオブジェクトを作成できる
- オブジェクトのキーと値を`:`で区切ったものを `{}` の中に書くことで作成と初期化が同時に行える
  - オブジェクトが持つキーのことをプロパティ名と呼ぶ
- プロパティを参照するには、`.`（ドット）でつないで参照する方法と、 `[]`（ブラケット）で参照する方法がある
```JavaScript
const obj = { "key": "value" };
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value"
```

### 配列リテラル
- `[`と`]`で値をカンマ区切りで囲み、その値を持つArrayオブジェクトを作成できる
  - 配列とは、複数の値に順序をつけて格納できるオブジェクトの一種である
- 作成した配列の要素を取得するには、配列に対して`array[index]`という構文で指定したインデックスの値を参照できる
```JavaScript
const array = ["index:0", "index:1", "index:2"];
// 0番目の要素を参照
console.log(array[0]); // => "index:0"
// 1番目の要素を参照
console.log(array[1]); // => "index:1"
```

### 正規表現リテラル
- 正規表現リテラルは`/`（スラッシュ）と`/`（スラッシュ）で正規表現のパターン文字列を囲む
```JavaScript
const numberRegExp = /\d+/; // 1文字以上の数字にマッチする正規表現
// `numberRegExp`の正規表現が文字列"123"にマッチするかをテストする
console.log(numberRegExp.test("123")); // => true
```

## プリミティブ型とオブジェクト
- 真偽値（Boolean）、数値（Number）、文字列（String）はそれぞれオブジェクトとして表現する方法もあり、**ラッパーオブジェクト**と呼ばれる
- ラッパーオブジェクトは、`new`演算子と対応するコンストラクタ関数を利用して作成できる
  - ラッパーオブジェクトは、オブジェクトの一種であるため`typeof`演算子の結果も`"object"`になる
  - オブジェクトであるためlengthプロパティなどのオブジェクトが持つプロパティを参照できる
  ```JavaScript
  // 文字列をラップしたStringラッパーオブジェクト
  const str = new String("文字列");
  // ラッパーオブジェクトは"object"型のデータ
  console.log(typeof str); // => "object"
  // Stringオブジェクトの`length`プロパティは文字列の長さを返す
  console.log(str.length); // => 3
  ```
  > JavaScriptではプリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがあるため、明示的にラッパーオブジェクトを使うべき理由はない
    ```JavaScript
  // 文字列をラップしたStringラッパーオブジェクト
  // プリミティブ型の文字列データ
  const str = "文字列";
  // プリミティブ型の文字列は"string"型のデータ
  console.log(typeof str); // => "string"
  // プリミティブ型の文字列も`length`プロパティを参照できる
  console.log(str.length); // => 3
  ```

## まとめ
- 7種類のプリミティブ型とオブジェクトがある
- リテラルはデータ型の値を直接記述できる構文として定義されたもの
- プリミティブ型の真偽値、数値、文字列、nullはリテラル表現がある
- オブジェクト型のオブジェクト、配列、正規表現にはリテラル表現がある
- プリミティブ型のデータでもプロパティアクセスができる